<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Flip Booklet Viewer</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="preconnect" href="https://cdnjs.cloudflare.com" />
<link rel="preconnect" href="https://cdn.jsdelivr.net" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/css/page-flip.css" />
<style>
  :root{
    --bg:#0f172a; --panel:#111827; --muted:#9ca3af; --text:#e5e7eb; --accent:#60a5fa;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
  .app{display:grid;grid-template-rows:auto 1fr auto;min-height:100svh}
  header,footer{display:flex;align-items:center;justify-content:space-between;background:var(--panel);padding:8px 12px;gap:10px}
  header{border-bottom:1px solid #1f2937}
  footer{border-top:1px solid #1f2937}
  .btn{background:#0b1220;border:1px solid #1f2937;color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
  .btn:hover{border-color:var(--accent)}
  .meta{color:var(--muted);font-size:13px;white-space:nowrap}
  .stage{position:relative;overflow:auto;padding:10px;display:grid;place-items:center}
  #flipRoot{width:min(1200px,96vw);height:calc(100svh - 120px); /* responsive height */ background:#0b1220;border:1px solid #1f2937;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.4),inset 0 0 0 1px #1f2937;display:flex;align-items:center;justify-content:center}
  /* Page content (images) */
  .page{
    width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#0a0f1e
  }
  .page img{max-width:100%;max-height:100%;display:block}
  .loader{color:var(--muted);font-size:14px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .input{background:#0b1220;border:1px solid #1f2937;color:var(--text);padding:8px 10px;border-radius:10px;min-width:240px}
  @media (max-width:768px){
    #flipRoot{height:calc(100svh - 150px)}
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="controls">
      <strong>Flip Booklet</strong>
      <span class="meta"> · Drag edge to flip · Swipe on mobile</span>
    </div>
    <div class="controls">
      <input id="src" class="input" placeholder="your.pdf or https://..." />
      <button class="btn" id="loadBtn">Load</button>
      <button class="btn" id="prevBtn">⟵ Prev</button>
      <button class="btn" id="nextBtn">Next ⟶</button>
    </div>
  </header>

  <div class="stage">
    <div id="flipRoot">
      <div class="loader" id="status">Waiting for PDF…</div>
    </div>
  </div>

  <footer>
    <div class="meta" id="pageLabel">—</div>
    <div class="controls">
      <button class="btn" id="fitBtn" title="Fit to container">Fit</button>
      <button class="btn" id="zoomOutBtn" title="Zoom out">–</button>
      <span class="meta" id="zoomLabel">100%</span>
      <button class="btn" id="zoomInBtn" title="Zoom in">+</button>
    </div>
  </footer>
</div>

<!-- PDF.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<!-- StPageFlip -->
<script src="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/js/page-flip.browser.min.js"></script>
<script>
(function(){
  const q = new URLSearchParams(location.search);
  const DEFAULT_SRC = q.get("src") || "your.pdf"; // or use ?src=https://drive.google.com/uc?export=download&id=FILE_ID
  const srcInput = document.getElementById("src");
  const loadBtn = document.getElementById("loadBtn");
  const prevBtn = document.getElementById("prevBtn");
  const nextBtn = document.getElementById("nextBtn");
  const fitBtn  = document.getElementById("fitBtn");
  const zoomInBtn = document.getElementById("zoomInBtn");
  const zoomOutBtn = document.getElementById("zoomOutBtn");
  const zoomLabel = document.getElementById("zoomLabel");
  const pageLabel = document.getElementById("pageLabel");
  const flipRoot = document.getElementById("flipRoot");
  const statusEl = document.getElementById("status");

  srcInput.value = DEFAULT_SRC;

  pdfjsLib.GlobalWorkerOptions.workerSrc =
    "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";

  let pdfDoc = null;
  let flip = null;
  let totalPages = 0;
  let basePagePx = { w: 800, h: 1131 }; // starting ratio; actual images will scale
  let zoom = 1.0;

  function setStatus(s){ if(statusEl) statusEl.textContent = s; }
  function setZoom(z){
    zoom = Math.min(2.5, Math.max(0.6, z));
    if (flip){
      flip.update({
        width: Math.round(basePagePx.w * zoom),
        height: Math.round(basePagePx.h * zoom),
      });
    }
    zoomLabel.textContent = Math.round(zoom*100) + "%";
  }

  function bestFitZoom(){
    // Compute a zoom that fits two pages (landscape) or one page (portrait) depending on container
    const padding = 24;
    const W = flipRoot.clientWidth - padding;
    const H = flipRoot.clientHeight - padding;

    // If the library is in portrait mode (single page), width = page width; otherwise 2*page width
    const twoPage = !(window.innerWidth < 768); // heuristic: small screens use portrait
    const needW = (twoPage ? basePagePx.w*2 : basePagePx.w);
    const needH = basePagePx.h;

    const z = Math.min(W / needW, H / needH);
    setZoom(z);
  }

  function onFlipChange(e){
    // Update page label to show logical current page(s)
    const idx = e.data; // 0-based page index within book
    // If cover is enabled, page numbers align with PDF page numbers.
    const pageNo = idx + 1;
    if (flip.getSettings().usePortrait || window.innerWidth < 768){
      pageLabel.textContent = `Page ${pageNo} / ${totalPages}`;
    } else {
      const right = Math.min(pageNo + 1, totalPages);
      pageLabel.textContent = `Pages ${pageNo}–${right} / ${totalPages}`;
    }
  }

  async function renderPdfPageToImage(pdf, n){
    const page = await pdf.getPage(n);
    // Render at a scale suitable for crisp flip (1.5x)
    const viewport = page.getViewport({ scale: 1.5 });
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    canvas.width = viewport.width;
    canvas.height = viewport.height;
    await page.render({ canvasContext: ctx, viewport }).promise;
    // Update base size from first page
    if (n === 1){ basePagePx = { w: canvas.width, h: canvas.height }; }
    return canvas.toDataURL("image/png");
  }

  function makePageDom(imgUrl, idx){
    const wrapper = document.createElement("div");
    wrapper.className = "page";
    wrapper.setAttribute("data-density","hard"); // slightly stiffer
    const img = document.createElement("img");
    img.alt = `Page ${idx}`;
    img.decoding = "async";
    img.loading = "lazy";
    img.src = imgUrl;
    wrapper.appendChild(img);
    return wrapper;
  }

  async function loadPDF(src){
    try{
      setStatus("Loading PDF…");
      const loadingTask = pdfjsLib.getDocument({ url: src, withCredentials:false });
      pdfDoc = await loadingTask.promise;
      totalPages = pdfDoc.numPages;

      // Clear previous flip
      flipRoot.innerHTML = "";
      const book = document.createElement("div");
      book.id = "book";
      flipRoot.appendChild(book);

      // Prepare StPageFlip
      flip = new St.PageFlip(book, {
        width: basePagePx.w,        // will be updated after first page
        height: basePagePx.h,
        size: "stretch",            // fit container while keeping aspect
        maxShadowOpacity: 0.3,
        showCover: true,            // first page acts as cover
        mobileScrollSupport: true,
        usePortrait: (window.innerWidth < 768) // single page on phones
      });

      // Render + add pages one by one (keeps UI responsive)
      setStatus("Rendering pages…");
      for(let i=1;i<=totalPages;i++){
        const url = await renderPdfPageToImage(pdfDoc, i);
        const pageDom = makePageDom(url, i);
        if (i === 1){
          // First add initializes the book
          flip.loadFromHTML([pageDom]);
          // Now we know real page size: update fit
          bestFitZoom();
        }else{
          flip.insertPage(pageDom, i-1);
        }
        if (i % 4 === 0) setStatus(`Rendering pages… ${i}/${totalPages}`);
      }
      setStatus("");

      flip.on("flip", onFlipChange);
      onFlipChange({ data: flip.getCurrentPageIndex() });

      // Make URL persistent
      history.replaceState(null, "", `?src=${encodeURIComponent(src)}`);

    }catch(err){
      console.error(err);
      setStatus("Failed to load PDF (check CORS / sharing).");
      alert("Couldn't load that PDF. If it's on Google Drive, use the uc?export=download&id=... link and set sharing to Anyone with the link.");
    }
  }

  // Controls
  prevBtn.addEventListener("click", ()=> flip && flip.flipPrev());
  nextBtn.addEventListener("click", ()=> flip && flip.flipNext());
  fitBtn .addEventListener("click", ()=> bestFitZoom());
  zoomInBtn.addEventListener("click", ()=> setZoom(zoom + 0.1));
  zoomOutBtn.addEventListener("click", ()=> setZoom(zoom - 0.1));
  window.addEventListener("resize", ()=> {
    if (!flip) return;
    flip.update({ usePortrait: (window.innerWidth < 768) });
    bestFitZoom();
  });

  // Keyboard: ← → to flip, +/- to zoom, F to fit
  window.addEventListener("keydown", (e)=>{
    const k = e.key.toLowerCase();
    if (k === "arrowleft"){ e.preventDefault(); prevBtn.click(); }
    else if (k === "arrowright"){ e.preventDefault(); nextBtn.click(); }
    else if (k === "+" || k === "="){ e.preventDefault(); zoomInBtn.click(); }
    else if (k === "-" || k === "_"){ e.preventDefault(); zoomOutBtn.click(); }
    else if (k === "f"){ e.preventDefault(); fitBtn.click(); }
  });

  // Init
  document.addEventListener("visibilitychange", ()=> {
    // When shown inside Google Sites, resizing/visibility can reflow; refit on return
    if (document.visibilityState === "visible" && flip) bestFitZoom();
  });

  loadBtn.addEventListener("click", ()=> loadPDF(srcInput.value.trim() || DEFAULT_SRC));
  // Initial load
  loadPDF(DEFAULT_SRC);
})();
</script>
</body>
</html>
